# 9. 시스템 아키텍처 리모델링

## 🏗️ DN_SOLUTION2 시스템 아키텍처 리모델링

### 9.1 현재 아키텍처 분석

#### 9.1.1 현재 시스템 구조
```
현재 아키텍처: Monolithic Architecture
├── Frontend: React + Redux + Material-UI
├── Backend: Django + DRF + PostgreSQL
├── Authentication: JWT Token
├── Storage: Local File System
└── Deployment: Single Server
```

#### 9.1.2 현재 시스템의 한계
```
확장성 한계:
- 모놀리식 구조로 인한 개별 기능 확장 어려움
- 단일 데이터베이스로 인한 성능 병목
- 프론트엔드/백엔드 결합도 높음

성능 한계:
- 실시간 처리 부족
- 대용량 엑셀 처리 시 서버 부하
- 캐싱 전략 부족

운영 한계:
- 배포 단위가 크고 위험도 높음
- 개별 서비스 모니터링 어려움
- 장애 격리 불가
```

### 9.2 리모델링 아키텍처 설계

#### 9.2.1 전체 아키텍처 개요
```
Target Architecture: Modular Monolith → Microservices Ready

┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Client Tier   │    │  Application    │    │   Data Tier     │
│                 │    │     Tier        │    │                 │
│ ┌─────────────┐ │    │ ┌─────────────┐ │    │ ┌─────────────┐ │
│ │ React SPA   │◄┼────┼►│ API Gateway │ │    │ │ PostgreSQL  │ │
│ │             │ │    │ │             │ │    │ │ (Primary)   │ │
│ │ - HQ Portal │ │    │ └─────────────┘ │    │ └─────────────┘ │
│ │ - Agency    │ │    │        │        │    │        │        │
│ │ - Retail    │ │    │        ▼        │    │        ▼        │
│ │             │ │    │ ┌─────────────┐ │    │ ┌─────────────┐ │
│ └─────────────┘ │    │ │ Core API    │ │    │ │ Redis       │ │
│        │        │    │ │ Services    │ │    │ │ (Cache)     │ │
│        ▼        │    │ │             │ │    │ └─────────────┘ │
│ ┌─────────────┐ │    │ │ ┌─────────┐ │ │    │        │        │
│ │ Mobile PWA  │ │    │ │ │ Auth    │ │ │    │        ▼        │
│ │ (Optional)  │ │    │ │ │ Service │ │ │    │ ┌─────────────┐ │
│ └─────────────┘ │    │ │ └─────────┘ │ │    │ │ File Store  │ │
└─────────────────┘    │ │ ┌─────────┐ │ │    │ │ (S3/Local)  │ │
                       │ │ │ Policy  │ │ │    │ └─────────────┘ │
┌─────────────────┐    │ │ │ Service │ │ │    │        │        │
│ External APIs   │    │ │ └─────────┘ │ │    │        ▼        │
│                 │    │ │ ┌─────────┐ │ │    │ ┌─────────────┐ │
│ ┌─────────────┐ │    │ │ │ Order   │ │ │    │ │ Message     │ │
│ │ SMS Service │◄┼────┼►│ │ Service │ │ │    │ │ Queue       │ │
│ └─────────────┘ │    │ │ └─────────┘ │ │    │ │ (Redis)     │ │
│ ┌─────────────┐ │    │ │ ┌─────────┐ │ │    │ └─────────────┘ │
│ │ Email       │◄┼────┼►│ │ Rebate  │ │ │    └─────────────────┘
│ │ Service     │ │    │ │ │ Service │ │ │                      
│ └─────────────┘ │    │ │ └─────────┘ │ │    ┌─────────────────┐
│ ┌─────────────┐ │    │ │ ┌─────────┐ │ │    │ Infrastructure  │
│ │ Push        │◄┼────┼►│ │ Report  │ │ │    │                 │
│ │ Notification│ │    │ │ │ Service │ │ │    │ ┌─────────────┐ │
│ └─────────────┘ │    │ │ └─────────┘ │ │    │ │ Docker      │ │
└─────────────────┘    │ └─────────────┘ │    │ │ Containers  │ │
                       │        │        │    │ └─────────────┘ │
┌─────────────────┐    │        ▼        │    │ ┌─────────────┐ │
│ Monitoring      │    │ ┌─────────────┐ │    │ │ Nginx       │ │
│                 │    │ │ WebSocket   │ │    │ │ (Reverse    │ │
│ ┌─────────────┐ │    │ │ Service     │ │    │ │  Proxy)     │ │
│ │ Prometheus  │◄┼────┼►│ (Real-time) │ │    │ └─────────────┘ │
│ └─────────────┘ │    │ └─────────────┘ │    │ ┌─────────────┐ │
│ ┌─────────────┐ │    │        │        │    │ │ SSL/TLS     │ │
│ │ Grafana     │ │    │        ▼        │    │ │ (Let's      │ │
│ └─────────────┘ │    │ ┌─────────────┐ │    │ │  Encrypt)   │ │
│ ┌─────────────┐ │    │ │ Background  │ │    │ └─────────────┘ │
│ │ ELK Stack   │◄┼────┼►│ Jobs        │ │    └─────────────────┘
│ │ (Logging)   │ │    │ │ (Celery)    │ │                      
│ └─────────────┘ │    │ └─────────────┘ │                      
└─────────────────┘    └─────────────────┘                      
```

#### 9.2.2 모듈화 전략
```python
# 서비스 분리 전략
MODULAR_SERVICES = {
    'auth_service': {
        'responsibility': 'Authentication & Authorization',
        'components': ['JWT Management', 'Role-based Access Control', 'Session Management'],
        'database': 'Shared PostgreSQL',
        'independence_level': 'Low'
    },
    
    'policy_service': {
        'responsibility': 'Policy Management & Distribution',
        'components': ['Policy CRUD', 'Group Management', 'Form Builder', 'Rebate Matrix'],
        'database': 'Dedicated Schema',
        'independence_level': 'High'
    },
    
    'order_service': {
        'responsibility': 'Order Processing & Workflow',
        'components': ['Order Creation', 'Approval Workflow', 'Status Management'],
        'database': 'Dedicated Schema',
        'independence_level': 'High'
    },
    
    'rebate_service': {
        'responsibility': 'Rebate Allocation & Settlement',
        'components': ['Allocation', 'Distribution', 'Usage Tracking', 'Settlement'],
        'database': 'Dedicated Schema',
        'independence_level': 'Medium'
    },
    
    'company_service': {
        'responsibility': 'Company & User Management',
        'components': ['Company CRUD', 'Hierarchy Management', 'User Management'],
        'database': 'Shared PostgreSQL',
        'independence_level': 'Low'
    },
    
    'report_service': {
        'responsibility': 'Reporting & Excel Generation',
        'components': ['Data Aggregation', 'Excel Generation', 'File Management'],
        'database': 'Read-only Replicas',
        'independence_level': 'Medium'
    },
    
    'notification_service': {
        'responsibility': 'Real-time Communication',
        'components': ['WebSocket Management', 'Push Notifications', 'Email/SMS'],
        'database': 'Redis + Message Queue',
        'independence_level': 'High'
    }
}
```

### 9.3 데이터 아키텍처 설계

#### 9.3.1 데이터베이스 분리 전략
```sql
-- 현재: Single Database
-- 목표: Schema-based Separation (단계적 마이크로서비스 준비)

-- Core Schema (공통)
CREATE SCHEMA core;
-- Tables: companies, company_users, telecom_providers, plans

-- Policy Schema
CREATE SCHEMA policy;
-- Tables: policies, policy_groups, policy_group_assignments, 
--         policy_rebates, order_form_fields, policy_form_fields

-- Order Schema  
CREATE SCHEMA orders;
-- Tables: customer_orders, order_status_logs, order_attachments

-- Rebate Schema
CREATE SCHEMA rebate;
-- Tables: rebate_allocations, rebate_settlements, 
--         settlement_approvals, settlement_summaries

-- Analytics Schema (Read-only)
CREATE SCHEMA analytics;
-- Views: aggregated data for reporting
```

#### 9.3.2 캐싱 전략
```python
# Redis 캐싱 구조
CACHE_STRUCTURE = {
    # 정책 캐시 (5분)
    'policy:list:{company_type}:{company_id}': 'JSON',
    'policy:detail:{policy_id}': 'JSON', 
    'policy:form_schema:{policy_id}': 'JSON',
    'policy:rebate_matrix:{policy_id}': 'JSON',
    
    # 사용자 세션 (30분)
    'user:session:{user_id}': 'JSON',
    'user:permissions:{user_id}': 'SET',
    'user:company:{user_id}': 'JSON',
    
    # 대시보드 데이터 (2분)
    'dashboard:{company_type}:{company_id}': 'JSON',
    
    # 주문 리스트 (1분)
    'orders:list:{company_id}:{filters_hash}': 'JSON',
    
    # 리베이트 잔액 (실시간)
    'rebate:balance:{company_id}': 'DECIMAL',
    
    # 엑셀 작업 상태 (1시간)
    'excel:task:{task_id}': 'JSON',
}

# 캐시 무효화 전략
CACHE_INVALIDATION = {
    'policy_updated': [
        'policy:list:*',
        'policy:detail:{policy_id}',
        'policy:form_schema:{policy_id}',
        'policy:rebate_matrix:{policy_id}'
    ],
    'order_created': [
        'orders:list:{company_id}:*',
        'dashboard:{company_type}:{company_id}',
        'rebate:balance:{company_id}'
    ],
    'rebate_allocated': [
        'rebate:balance:{company_id}',
        'dashboard:{company_type}:{company_id}'
    ]
}
```

### 9.4 API Gateway 설계

#### 9.4.1 API Gateway 구조
```python
# api_gateway/routes.py
API_ROUTES = {
    # Authentication Routes
    '/api/auth/*': {
        'service': 'auth_service',
        'rate_limit': '100/minute',
        'cache': False,
        'auth_required': False
    },
    
    # Policy Routes
    '/api/policies/*': {
        'service': 'policy_service', 
        'rate_limit': '200/minute',
        'cache': True,
        'cache_ttl': 300,  # 5 minutes
        'auth_required': True
    },
    
    # Order Routes
    '/api/orders/*': {
        'service': 'order_service',
        'rate_limit': '300/minute', 
        'cache': False,
        'auth_required': True
    },
    
    # Rebate Routes
    '/api/rebates/*': {
        'service': 'rebate_service',
        'rate_limit': '150/minute',
        'cache': True,
        'cache_ttl': 60,  # 1 minute
        'auth_required': True
    },
    
    # Company Routes
    '/api/companies/*': {
        'service': 'company_service',
        'rate_limit': '100/minute',
        'cache': True, 
        'cache_ttl': 600,  # 10 minutes
        'auth_required': True
    },
    
    # Export Routes
    '/api/exports/*': {
        'service': 'report_service',
        'rate_limit': '10/minute',  # 낮은 제한
        'cache': False,
        'auth_required': True,
        'timeout': 300  # 5 minutes
    }
}

# Gateway Middleware
class APIGatewayMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response
        
    def __call__(self, request):
        # 1. Rate Limiting
        if not self.check_rate_limit(request):
            return JsonResponse({'error': 'Rate limit exceeded'}, status=429)
        
        # 2. Authentication
        if not self.check_authentication(request):
            return JsonResponse({'error': 'Authentication required'}, status=401)
        
        # 3. Route to Service
        service_response = self.route_to_service(request)
        
        # 4. Response Processing
        return self.process_response(service_response)
    
    def check_rate_limit(self, request):
        """Rate limiting 체크"""
        client_id = self.get_client_id(request)
        route_config = self.get_route_config(request.path)
        
        if not route_config:
            return True
            
        rate_limit = route_config.get('rate_limit')
        if not rate_limit:
            return True
            
        # Redis를 이용한 Rate Limiting
        return self.redis_rate_limit(client_id, rate_limit)
    
    def route_to_service(self, request):
        """해당 서비스로 라우팅"""
        route_config = self.get_route_config(request.path)
        service_name = route_config['service']
        
        # 캐시 확인
        if route_config.get('cache'):
            cached_response = self.get_cached_response(request)
            if cached_response:
                return cached_response
        
        # 서비스 호출
        response = self.call_service(service_name, request)
        
        # 캐시 저장
        if route_config.get('cache') and response.status_code == 200:
            self.cache_response(request, response, route_config.get('cache_ttl', 300))
        
        return response
```

### 9.5 실시간 통신 아키텍처

#### 9.5.1 WebSocket 아키텍처
```python
# websocket/architecture.py
WEBSOCKET_ARCHITECTURE = {
    'connection_management': {
        'type': 'Redis-backed Channel Layer',
        'scaling': 'Multiple Django instances',
        'persistence': 'Redis Cluster',
        'fallback': 'Database notifications'
    },
    
    'message_types': {
        'order_notifications': {
            'targets': ['hq', 'agency', 'retail'],
            'events': ['created', 'approved', 'rejected', 'shipped'],
            'priority': 'high'
        },
        'rebate_notifications': {
            'targets': ['hq', 'agency', 'retail'],
            'events': ['allocated', 'distributed', 'used'],
            'priority': 'medium'
        },
        'policy_notifications': {
            'targets': ['agency', 'retail'],
            'events': ['assigned', 'updated'],
            'priority': 'medium'
        },
        'system_notifications': {
            'targets': ['all'],
            'events': ['maintenance', 'update'],
            'priority': 'low'
        }
    },
    
    'routing_strategy': {
        'company_based': {
            'pattern': 'notifications_{company_id}',
            'use_case': 'Company-specific notifications'
        },
        'role_based': {
            'pattern': 'role_{company_type}',
            'use_case': 'Role-specific broadcasts'
        },
        'user_based': {
            'pattern': 'user_{user_id}',
            'use_case': 'Personal notifications'
        }
    }
}

# WebSocket Connection Manager
class WebSocketManager:
    def __init__(self):
        self.redis_client = redis.StrictRedis(
            host=settings.REDIS_HOST,
            port=settings.REDIS_PORT,
            db=settings.REDIS_WEBSOCKET_DB
        )
    
    async def notify_company(self, company_id, notification_data):
        """업체별 알림"""
        channel_layer = get_channel_layer()
        await channel_layer.group_send(
            f'notifications_{company_id}',
            {
                'type': 'notification_message',
                'data': notification_data
            }
        )
    
    async def notify_role(self, role, notification_data):
        """역할별 알림"""
        channel_layer = get_channel_layer()
        await channel_layer.group_send(
            f'role_{role}',
            {
                'type': 'notification_message', 
                'data': notification_data
            }
        )
    
    async def notify_user(self, user_id, notification_data):
        """개인별 알림"""
        channel_layer = get_channel_layer()
        await channel_layer.group_send(
            f'user_{user_id}',
            {
                'type': 'notification_message',
                'data': notification_data
            }
        )
    
    def get_connection_stats(self):
        """연결 통계"""
        return {
            'total_connections': self.redis_client.scard('active_connections'),
            'company_groups': self.redis_client.keys('notifications_*'),
            'role_groups': self.redis_client.keys('role_*'),
            'user_groups': self.redis_client.keys('user_*')
        }
```

### 9.6 보안 아키텍처

#### 9.6.1 인증 및 권한 시스템
```python
# security/architecture.py
SECURITY_ARCHITECTURE = {
    'authentication': {
        'primary': 'JWT (Access + Refresh Token)',
        'session_management': 'Redis-based',
        'token_rotation': 'Automatic refresh',
        'multi_device': 'Supported'
    },
    
    'authorization': {
        'model': 'RBAC (Role-Based Access Control)',
        'levels': ['Company Type', 'Role', 'Resource'],
        'inheritance': 'Hierarchical permissions',
        'caching': 'Redis-cached permissions'
    },
    
    'data_protection': {
        'encryption_at_rest': 'AES-256',
        'encryption_in_transit': 'TLS 1.3',
        'sensitive_data': 'Field-level encryption',
        'key_management': 'HashiCorp Vault (Future)'
    },
    
    'api_security': {
        'rate_limiting': 'Redis-based sliding window',
        'input_validation': 'DRF Serializers',
        'output_sanitization': 'Custom serializers',
        'cors': 'Whitelist-based'
    }
}

# Permission System
class EnhancedPermissionSystem:
    def __init__(self):
        self.redis_client = redis.StrictRedis()
    
    def check_permission(self, user, action, resource, resource_id=None):
        """향상된 권한 확인"""
        cache_key = f'perm:{user.id}:{action}:{resource}:{resource_id}'
        
        # 캐시 확인
        cached_result = self.redis_client.get(cache_key)
        if cached_result is not None:
            return cached_result.decode() == 'True'
        
        # 권한 계산
        has_permission = self._calculate_permission(user, action, resource, resource_id)
        
        # 캐시 저장 (5분)
        self.redis_client.setex(cache_key, 300, str(has_permission))
        
        return has_permission
    
    def _calculate_permission(self, user, action, resource, resource_id):
        """권한 계산 로직"""
        company_user = user.company_user
        company = company_user.company
        
        # 회사 타입별 기본 권한
        base_permissions = self.get_base_permissions(company.type)
        if not base_permissions.get(resource, {}).get(action, False):
            return False
        
        # 리소스별 세부 권한 확인
        if resource_id:
            return self.check_resource_permission(company, action, resource, resource_id)
        
        return True
    
    def invalidate_user_cache(self, user_id):
        """사용자 권한 캐시 무효화"""
        pattern = f'perm:{user_id}:*'
        keys = self.redis_client.keys(pattern)
        if keys:
            self.redis_client.delete(*keys)
```

### 9.7 성능 최적화 아키텍처

#### 9.7.1 캐싱 계층 설계
```python
# caching/layers.py
CACHING_LAYERS = {
    'L1_Application_Cache': {
        'type': 'In-Memory (Django Cache)',
        'ttl': '30 seconds',
        'use_case': 'Hot data, frequent access',
        'examples': ['User sessions', 'Active policies']
    },
    
    'L2_Distributed_Cache': {
        'type': 'Redis Cluster',
        'ttl': '5-60 minutes',
        'use_case': 'Shared data across instances',
        'examples': ['Policy lists', 'Company hierarchy', 'Form schemas']
    },
    
    'L3_Database_Cache': {
        'type': 'PostgreSQL Query Cache',
        'ttl': 'Until data change',
        'use_case': 'Complex query results',
        'examples': ['Aggregated reports', 'Statistics']
    },
    
    'CDN_Cache': {
        'type': 'CloudFlare/AWS CloudFront',
        'ttl': '1 hour - 1 day',
        'use_case': 'Static assets',
        'examples': ['JS/CSS bundles', 'Images', 'Fonts']
    }
}

# Cache Manager
class CacheManager:
    def __init__(self):
        self.redis_client = redis.StrictRedis()
        self.local_cache = {}
    
    def get(self, key, fetch_function=None, ttl=300):
        """다층 캐시 조회"""
        # L1: Local cache
        if key in self.local_cache:
            if not self._is_expired(self.local_cache[key]):
                return self.local_cache[key]['data']
        
        # L2: Redis cache
        redis_data = self.redis_client.get(key)
        if redis_data:
            data = json.loads(redis_data)
            # L1에 복사
            self.local_cache[key] = {
                'data': data,
                'expires_at': time.time() + 30  # 30초 로컬 캐시
            }
            return data
        
        # L3: Database fetch
        if fetch_function:
            data = fetch_function()
            self.set(key, data, ttl)
            return data
        
        return None
    
    def set(self, key, data, ttl=300):
        """다층 캐시 저장"""
        # L1: Local cache (30초)
        self.local_cache[key] = {
            'data': data,
            'expires_at': time.time() + 30
        }
        
        # L2: Redis cache
        self.redis_client.setex(key, ttl, json.dumps(data, default=str))
    
    def invalidate(self, pattern):
        """캐시 무효화"""
        # Local cache
        keys_to_remove = [k for k in self.local_cache.keys() if fnmatch.fnmatch(k, pattern)]
        for key in keys_to_remove:
            del self.local_cache[key]
        
        # Redis cache
        redis_keys = self.redis_client.keys(pattern)
        if redis_keys:
            self.redis_client.delete(*redis_keys)
```

#### 9.7.2 데이터베이스 최적화
```python
# database/optimization.py
DATABASE_OPTIMIZATION = {
    'read_replicas': {
        'master': 'Write operations',
        'replica_1': 'Report queries',
        'replica_2': 'Dashboard queries',
        'load_balancing': 'Round-robin'
    },
    
    'connection_pooling': {
        'pool_size': 20,
        'max_overflow': 30,
        'pool_timeout': 30,
        'pool_recycle': 3600
    },
    
    'query_optimization': {
        'indexing_strategy': 'Compound indexes for common queries',
        'query_analysis': 'EXPLAIN ANALYZE for slow queries',
        'orm_optimization': 'select_related, prefetch_related',
        'raw_queries': 'For complex aggregations'
    }
}

# Database Router
class DatabaseRouter:
    """데이터베이스 라우팅"""
    
    def db_for_read(self, model, **hints):
        """읽기 작업 라우팅"""
        if model._meta.app_label in ['reports', 'analytics']:
            return 'replica'
        return 'default'
    
    def db_for_write(self, model, **hints):
        """쓰기 작업 라우팅"""
        return 'default'
    
    def allow_migrate(self, db, app_label, model_name=None, **hints):
        """마이그레이션 허용"""
        if db == 'replica':
            return False
        return True

# Query Optimizer
class QueryOptimizer:
    @staticmethod
    def optimize_order_queries():
        """주문 쿼리 최적화"""
        return CustomerOrder.objects.select_related(
            'company',
            'policy',
            'selected_plan__telecom_provider',
            'created_by'
        ).prefetch_related(
            'order_status_logs',
            'order_attachments'
        )
    
    @staticmethod
    def optimize_policy_queries():
        """정책 쿼리 최적화"""
        return Policy.objects.select_related(
            'created_by__company'
        ).prefetch_related(
            Prefetch(
                'policy_rebates',
                queryset=PolicyRebate.objects.select_related('telecom_provider')
            ),
            Prefetch(
                'policy_form_fields',
                queryset=PolicyFormField.objects.select_related('field').order_by('order_index')
            )
        )
```

### 9.8 모니터링 및 로깅 아키텍처

#### 9.8.1 모니터링 스택
```python
# monitoring/stack.py
MONITORING_STACK = {
    'metrics': {
        'collector': 'Prometheus',
        'storage': 'Time-series DB',
        'visualization': 'Grafana',
        'alerting': 'Prometheus Alertmanager'
    },
    
    'logging': {
        'collection': 'Fluentd/Filebeat',
        'processing': 'Logstash',
        'storage': 'Elasticsearch',
        'visualization': 'Kibana'
    },
    
    'tracing': {
        'instrumentation': 'Django-OpenTelemetry',
        'collection': 'Jaeger/Zipkin',
        'analysis': 'Distributed tracing'
    },
    
    'uptime': {
        'external': 'Pingdom/UptimeRobot',
        'internal': 'Health check endpoints'
    }
}

# Custom Metrics
class MetricsCollector:
    def __init__(self):
        self.redis_client = redis.StrictRedis()
    
    def record_api_call(self, endpoint, method, status_code, response_time):
        """API 호출 메트릭"""
        metrics = {
            'endpoint': endpoint,
            'method': method,
            'status_code': status_code,
            'response_time': response_time,
            'timestamp': time.time()
        }
        
        # Prometheus 메트릭
        api_calls_total.labels(
            endpoint=endpoint,
            method=method,
            status=status_code
        ).inc()
        
        api_response_time.labels(
            endpoint=endpoint
        ).observe(response_time)
    
    def record_business_metric(self, metric_type, value, labels=None):
        """비즈니스 메트릭"""
        if metric_type == 'order_created':
            orders_total.labels(**(labels or {})).inc()
        elif metric_type == 'rebate_allocated':
            rebate_allocated_total.labels(**(labels or {})).inc(value)
        elif metric_type == 'policy_assigned':
            policies_assigned_total.labels(**(labels or {})).inc()

# Health Check System
class HealthChecker:
    def check_database(self):
        """데이터베이스 상태 확인"""
        try:
            from django.db import connection
            with connection.cursor() as cursor:
                cursor.execute("SELECT 1")
            return {'status': 'healthy', 'response_time': 0.001}
        except Exception as e:
            return {'status': 'unhealthy', 'error': str(e)}
    
    def check_redis(self):
        """Redis 상태 확인"""
        try:
            redis_client = redis.StrictRedis()
            redis_client.ping()
            return {'status': 'healthy'}
        except Exception as e:
            return {'status': 'unhealthy', 'error': str(e)}
    
    def check_services(self):
        """외부 서비스 상태 확인"""
        services = {}
        
        # SMS 서비스
        services['sms'] = self.check_external_service('SMS_API_URL')
        
        # Email 서비스
        services['email'] = self.check_external_service('EMAIL_API_URL')
        
        return services
    
    def get_health_status(self):
        """전체 시스템 상태"""
        return {
            'database': self.check_database(),
            'redis': self.check_redis(),
            'services': self.check_services(),
            'timestamp': timezone.now().isoformat()
        }
```

### 9.9 배포 아키텍처

#### 9.9.1 Docker 컨테이너화
```dockerfile
# Dockerfile.backend
FROM python:3.11-slim

WORKDIR /app

# 시스템 의존성
RUN apt-get update && apt-get install -y \
    gcc \
    postgresql-client \
    && rm -rf /var/lib/apt/lists/*

# Python 의존성
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 앱 코드
COPY . .

# 환경 설정
ENV PYTHONPATH=/app
ENV DJANGO_SETTINGS_MODULE=config.settings.production

# 헬스체크
HEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \
    CMD python manage.py check || exit 1

# 포트 노출
EXPOSE 8000

# 실행
CMD ["gunicorn", "--bind", "0.0.0.0:8000", "--workers", "4", "config.wsgi:application"]
```

```dockerfile
# Dockerfile.frontend
FROM node:18-alpine as builder

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build

FROM nginx:alpine
COPY --from=builder /app/build /usr/share/nginx/html
COPY nginx.conf /etc/nginx/nginx.conf

EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

#### 9.9.2 Docker Compose 구성
```yaml
# docker-compose.yml
version: '3.8'

services:
  # 데이터베이스
  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: dn_solution2
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DB_USER}"]
      interval: 10s
      timeout: 5s
      retries: 5

  # 캐시
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 3

  # 백엔드 API
  backend:
    build:
      context: .
      dockerfile: Dockerfile.backend
    environment:
      - DATABASE_URL=postgresql://${DB_USER}:${DB_PASSWORD}@postgres:5432/dn_solution2
      - REDIS_URL=redis://redis:6379
      - DEBUG=False
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    ports:
      - "8000:8000"
    volumes:
      - media_files:/app/media
      - static_files:/app/static
    restart: unless-stopped

  # 백그라운드 작업
  celery:
    build:
      context: .
      dockerfile: Dockerfile.backend
    command: celery -A config worker -l info --concurrency=4
    environment:
      - DATABASE_URL=postgresql://${DB_USER}:${DB_PASSWORD}@postgres:5432/dn_solution2
      - REDIS_URL=redis://redis:6379
    depends_on:
      - postgres
      - redis
    volumes:
      - media_files:/app/media
    restart: unless-stopped

  # 프론트엔드
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile.frontend
    ports:
      - "80:80"
      - "443:443"
    depends_on:
      - backend
    restart: unless-stopped

  # Nginx 리버스 프록시
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./nginx/ssl:/etc/nginx/ssl
      - static_files:/var/www/static
      - media_files:/var/www/media
    depends_on:
      - backend
      - frontend
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:
  media_files:
  static_files:
```

### 9.10 구현 로드맵

#### 9.10.1 Phase 1: 인프라 구축 (4주)
```
Week 1-2: Docker 컨테이너화
✅ Dockerfile 작성
✅ Docker Compose 구성
✅ 개발/프로덕션 환경 분리

Week 3-4: 캐싱 시스템
✅ Redis 클러스터 구성
✅ 캐싱 레이어 구현
✅ 캐시 무효화 전략
```

#### 9.10.2 Phase 2: 모듈화 (6주)
```
Week 1-2: 서비스 분리 준비
✅ 스키마 분리
✅ 서비스 레이어 구조화
✅ API 경계 정의

Week 3-4: 핵심 서비스 모듈화
✅ Policy Service 분리
✅ Order Service 분리
✅ Rebate Service 분리

Week 5-6: 지원 서비스 모듈화
✅ Report Service 분리
✅ Notification Service 분리
✅ API Gateway 구현
```

#### 9.10.3 Phase 3: 성능 최적화 (4주)
```
Week 1-2: 데이터베이스 최적화
✅ Read Replica 구성
✅ 쿼리 최적화
✅ 인덱스 최적화

Week 3-4: 애플리케이션 최적화
✅ 비동기 처리 확대
✅ 배치 작업 최적화
✅ API 응답 최적화
```

#### 9.10.4 Phase 4: 모니터링 구축 (3주)
```
Week 1: 메트릭 수집
✅ Prometheus 설정
✅ 커스텀 메트릭 구현
✅ Grafana 대시보드

Week 2: 로깅 시스템
✅ ELK Stack 구성
✅ 로그 수집/분석
✅ 알림 시스템

Week 3: 헬스체크 시스템
✅ 서비스 상태 모니터링
✅ 자동 복구 메커니즘
✅ SLA 모니터링
```

#### 9.10.5 Phase 5: 보안 강화 (2주)
```
Week 1: 인증/권한 강화
✅ JWT 토큰 개선
✅ 권한 캐싱 최적화
✅ API 보안 강화

Week 2: 데이터 보안
✅ 암호화 강화
✅ 취약점 검사
✅ 보안 정책 수립
```

이 아키텍처는 현재 모놀리식 구조에서 단계적으로 마이크로서비스로 전환할 수 있는 확장 가능한 설계입니다.